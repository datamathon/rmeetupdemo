
---
title: R meetup - Oslo (June 2014)
output:
  html_document:
    toc: true
    theme: united
  pdf_document:
    toc: true
    highlight: zenburn
---


---------


Setup
-----

install R, dependencies, rmeetupdemo package


---------


Data structures
---------------

Before we begin two things:
1. R indexes start from 1 not 0.
2. idiomatic assignment is done with the `<-` operator.

Core data structures: vector, matrix, list, dataframe.

```{r, message = FALSE, warning = FALSE}
# vector (homogenous)
vec <- c(1, 2, 3)
vec

str(vec)

# matrix (homogenous, I very seldom use them explicitly)
m <- matrix(1:6, ncol = 3, nrow = 2)
m

# lists (heterogenuous, often used)
a_list <- list(elem1 = 1, elem2 = c(1, 2, 3))
a_list

str(a_list)

# dateframe (the workhorse tabular data structure)
# think of it as a list of equal length named vectors
dat <- data.frame(x = 1:5, y = c('leon', 'charl', 'du', 'toit', 'ble'))
dat

str(dat)
```

Subsetting and indexing into data structures. There are two types of subsetting: 1) preserving which returns a subset of the data structure as the same class and 2) simplifying, which returns a subset as a class of what that element is. Let's make it concrete. Preserving looks like `[]` while simplifying looks like `[[]]` or `$`.

```{r, message = FALSE, warning = FALSE}
# we now have some objects in the environment
# let's have a look what they are
ls()

# a vector is atomic - no simplification possible
vec[1]

class(vec[1])

# matrices are vectors with a dimension attribute - attributes are metadata
attributes(m)

# or
dim(m)

# lists are not atomic and can be subsetted without simplification
a_list[1]

# or with
a_list[[1]]

class(a_list[1])

class(a_list[[1]])

# the same goes for dataframes
dat[1]

dat[[1]]

class(dat[1])

class(dat[[1]])

# other attributes of dataframes
names(dat)

dim(dat)

# the `$` operator is a shorthand for `[[]]` with fuzzy matching
dat$mynewcol <- rep(5, 5)
dat

dat$my

# One of the biggest gotchas...
# when passing a dataframe into a function
# and using column names for access I always use `[[]]`
# this is why

col <- "mynewcol"

dat[[col]]

#but
dat$col


```

-----

Functional goodies
------------------

```{r, message = FALSE, warning = FALSE}

#vectorised
unlist(Map(function(x) { 10 * x }, 1:10))

#lambdas
#first class functions

Reduce(sum, Map(function(x) { x*x }, Filter(Negate(function(x) {x %% 2 == 0}), 1:100)))

#iffys

```

-----


Exploring the data with dplyr
-----------------------------

[dplyr](https://github.com/hadley/dplyr) is a package specialised for data manipulation in data analysis. It has three main goals (in the words of the authors): 1) make the most important data manipulation verbs easily available in R; 2) performance for in-memory data; and 3) provide the same API for different in-memory and out-of-memomry data stores. Practially speaking, therefore, you could sample your data, figure it out in memory and execute the same code on your Redshift cluster.



Let's manipulate the SSB immigration data and then talk about what the code is doing.

```{r, eval = FALSE, message = FALSE, warning = FALSE}

library(dplyr)
library(rmeetupdemo)

imm_data <- create_immigration_df()

# let's have a look at the data
basic_plot(imm_data)

# a more in-depth look (remove noise)
elaborate_plot(clean_data(imm_data))

# let's look at growth rates instead
# we'll calculate them using dplyr
# this will show some neat features
imm_growth <- imm_data %>%
  group_by(background, sex) %>%
  mutate(percentage_change = round((value - lag(value))/value*100, 2))

imm_growth %>%
  select(time, background, sex, value, percentage_change) %>%
  glimpse()

```

Now that we have some interesting data about the growth rates of immigration to Norway, let's expose it via a REST API endpoint.


-----


Making a REST app
-----------------

Create a file for the app: `$ touch restssb.r`. Fill it with the following code to make a basic REST app.

```{r, eval = FALSE, message = FALSE, warning = FALSE}

library(Rook)
library(dplyr)
library(jsonlite)

ssb_data <- tbl_df(
  read.csv(
    "./data/ssb_immigration_data.csv",
    stringsAsFactors = FALSE))

immigration_growth <- function(data) {
  data %>%
    group_by(background, sex) %>%
    mutate(percentage_change = round((value - lag(value))/value*100, 2)) %>%
    select(time, background, sex, value, percentage_change)
}

server <- Rhttpd$new()

server$add(
  name = "immigration",
  app = function(env) {
    request <- Request$new(env)
    response <- Response$new()
    growth_data <- immigration_growth(ssb_data)
    response$write(toJSON(growth_data))
    response$finish()
  }
)

server$start(port = '8004')


```

To run this do `> source('./restssb.r')`. A finished example is in `rmeetupdemo/examples/restapp`. Browse to `http://127.0.0.1:8004/custom/immigration` to see the data.


-----


Making a dashboard
------------------

Let's consume the api endpoint we just made and present the data in a graph on a dashboard.


---
title: R meetup - Oslo (October 2014)
output:
  html_document:
    toc: true
    theme: united
  pdf_document:
    toc: true
    highlight: zenburn
---


---------


Setup
-----

install R, dependencies, rmeetupdemo package


---------


Data structures
---------------

Before we begin two things:
1. R indexes start from 1 not 0.
2. idiomatic assignment is done with the `<-` operator.

Core data structures: vector, matrix, list, dataframe.

```{r, message = FALSE, warning = FALSE}
# vector (homogenous)
vec <- c(1, 2, 3)
vec

str(vec)

# matrix (homogenous, I very seldom use them explicitly)
m <- matrix(1:6, ncol = 3, nrow = 2)
m

# lists (heterogenuous, often used)
a_list <- list(elem1 = 1, elem2 = c(1, 2, 3))
a_list

str(a_list)

# dateframe (the workhorse tabular data structure)
# think of it as a list of equal length named vectors
dat <- data.frame(x = 1:5, y = c('leon', 'charl', 'du', 'toit', 'ble'), stringsAsFactors = FALSE)
dat

str(dat)
```

Subsetting and indexing into data structures. There are two types of subsetting: 1) preserving which returns a subset of the data structure as the same class and 2) simplifying, which returns a subset as a class of what that element is. Let's make it concrete. Preserving looks like `[]` while simplifying looks like `[[]]` or `$`.

```{r, message = FALSE, warning = FALSE}
# we now have some objects in the environment
# let's have a look what they are
ls()

# a vector is atomic - no simplification possible
vec[1]

class(vec[1])

# matrices are vectors with a dimension attribute - attributes are metadata
attributes(m)

# or
dim(m)

# lists are not atomic and can be subsetted without simplification
a_list[1]

# or with
a_list[[1]]

class(a_list[1])

class(a_list[[1]])

# the same goes for dataframes
dat[1]

dat[[1]]

class(dat[1])

class(dat[[1]])

# other attributes of dataframes
names(dat)

dim(dat)

# the `$` operator is a shorthand for `[[]]` with fuzzy matching
dat$mynewcol <- rep(5, 5)
dat

dat$my

# One of the biggest gotchas...
# when passing a dataframe into a function
# and using column names for access I always use `[[]]`
# this is why

col <- "mynewcol"

dat[[col]]

#but
dat$col


```

-----

Functions
---------

```{r, echo = FALSE, eval = FALSE}
#TODO
```

-----


Functional goodies
------------------

```{r, message = FALSE, warning = FALSE}

#vectorised
unlist(Map(function(x) { 10 * x }, 1:10))

#lambdas
#first class functions

Reduce(sum, Map(function(x) { x*x }, Filter(Negate(function(x) {x %% 2 == 0}), 1:100)))

#iffys

```

-----


Exploring the data with dplyr
-----------------------------

[dplyr](https://github.com/hadley/dplyr) is a package specialised for data manipulation in data analysis. It has three main goals (in the words of the authors): 1) make the most important data manipulation verbs easily available in R; 2) performance for in-memory data; and 3) provide the same API for different in-memory and out-of-memomry data stores. Practially speaking, therefore, you could sample your data, figure it out in memory and execute the same code on your Redshift cluster.



Let's manipulate the SSB immigration data and then talk about what the code is doing.

```{r, eval = FALSE, message = FALSE, warning = FALSE}

library(dplyr)
library(rmeetupdemo)

imm_data <- create_immigration_df()

# let's have a look at the data
basic_plot(imm_data)

# a more in-depth look (remove noise)
elaborate_plot(clean_data(imm_data))

# let's look at growth rates instead
# we'll calculate them using dplyr
# this will show some neat features
imm_growth <- imm_data %>%
  group_by(background, sex) %>%
  mutate(percentage_change = round((value - lag(value))/value*100, 2))

imm_growth %>%
  select(time, background, sex, value, percentage_change) %>%
  glimpse()
```

First we load `dplyr` and `rmeetupdemo` packages. Then we create the immigration data frame. We can use two plotting functions from `rmeetupdemo` to have a look at the data. Then we use the data manipulation capabilities of `dplyr` to add another column to the data frame. We calculate the year-on-year percentage change of immigration grouped by background and sex.

Let's step through the `dplyr` code. First though, a pause on the `%>%` operator is in order. In R one can define arbitrary operators by placing any character or set of characters between two `%` signs. We could, therefore, make our own multiply operator as such: ``` `%mult%` <- function(a, b) { a * b } ``` and use it in the familiar infix way as such: `4 %mult% 4`. 

The `%>%` operator was defined in this way by the author of the [magrittr](https://github.com/smbache/magrittr) package. It is similar to F#'s pipe-forward operator `|>`, or Clojure's threading macro `->>`. In general it allows you to write ` g(f(x, y), z)` as `x %>% f(y) %>% g(z)`. In our example above the following statements are therefore equivalent:

```{r, eval = FALSE, label = magrittr_example}
# without the pipe
mutate(group_by(df, background, sex), percentage_change = round((value - lag(value))/value*100, 2))

# with the pipe
df %>% group_by(background, sex) %>% mutate(percentage_change = round((value - lag(value))/value*100, 2))
```

The motivation is that it makes code more readable. By avoiding deep nesting it can help promote clear code especially in the context of data manipulation. Stepping through the `dplyr` code is easy now. First we group the data according to `backgroun` and `sex`, and then we calculate the percentage change per group. The call to `mutate` means that we want to change the data frame by adding another column.


-----

Visualise the growth rate with ggvis
------------------------------------



-----



Make an interactive Rmd document
--------------------------------

Notes:
* http://rmarkdown.rstudio.com/authoring_shiny.html
* http://ggvis.rstudio.com/interactivity.html#shiny-apps
* https://github.com/yihui/knitr-examples/blob/master/065-rmd-chunk.Rmd
* https://github.com/rstudio/ggvis/tree/master/demo/rmarkdown

```{r setup, echo = FALSE, message = FALSE}
library(knitr)
knit_hooks$set(wrapper = function(before, options, envir) {
  if (before) {
    sprintf('    ```{r %s}\n', options$params.src)
  } else '    ```\n'
})
```

A basic R Markdown code block is constructed like this:

```{r, eval = FALSE, echo = TRUE, message = FALSE, warning = FALSE, label = mylabel, wrapper = TRUE}
# code goes here...
```
The `r wrapper = TRUE` option is set to display the code chunk in addition to evaluating it.

-----


Making a dashboard - deploy the document with Shiny server
----------------------------------------------------------

We will use the [Rstudio IDE](http://www.rstudio.com/products/RStudio/) to run this locally - [download](http://www.rstudio.com/products/rstudio/download/).


-----

Use devtools and roxygen2 to package our code
---------------------------------------------

[devtools](https://github.com/hadley/devtools) is a package for package development. You don't need to use it but it makes life easier.

In the interactive R session, navigate to a place in your directory tree outside of the rmeetupdemo package - somewhere where you can initialize a new git repo. 

```{r, eval = FALSE, label = create_new_package}
setwd("~/") # or whatever path you prefer
library(devtools)
create("my_new_package")
```

Now create a file in the `R` directory named `immigration_manip.R`. This will hold our package code. Put this into the file:

```{r, eval = FALSE, label = R_package_code}

#' @import dplyr

#' @export
add_growth_rates <- function(df) {
  df %>%
    group_by(background, sex) %>%
    mutate(percentage_change = round((value - lag(value))/value*100, 2))
}

```
Let's step through the few lines of code from top to bottom. In this file we use annotated comments to produce documentation and to generate the necessary code in the `DESCRIPTION` file - this will hangle the dependency on `dplyr`, by making sure it will be loaded when we load our own package. Using this style of commenting we say that we want to import `dplyr` when loading this code. We also annotate the function to add grwoth rates to the data with `#' @export`. Here we are saying that we want this function to be available to package users. It is equivalent to declaring a class method public. We then define the function.

Now let's build documentation and install this package into R locally:

```{r, eval = FALSE, label = R_package_install}
library(roxygen2)
roxygenise("mypackage") # use your package name
install("mypackage")
```

Check the contents of the DESCRIPTION file - you should see and instruction to export the function. Next we can use the package with the `rmeetupdemo` package.

```{r, eval = FALSE, label = R_package_use}
library(rmeetupdemo)
library(mypackage)
df <- clean_data(create_immigration_df())
add_growth_rates(df)
```

We can now refactor the dashboard to use our package. This is, in my experience, a good design pattern: keep data manipulation code in one place, and the interactive visualization elsewhere.

```{r, eval = FALSE, label = R_package_refactor_dashboard}
#TODO
```

-----

Recommended further reading
---------------------------










